// FUP - Fuck Unclosed Parens

Input = _{ SOI ~ OperatorExpression+ ~ EOI }

// Expression of infix operators.
OperatorExpression = {
	FupExpression ~ (FupInfixOp ~ FupExpression)*
}

// Expression which cannot be direcly embedded in Scheme because it would be ambiguous.
FupExpression = {
	FupTerm
}

// Expression which is unambiguous to Scheme expressions.
FupTerm = {
	FupQuote |
	FupDefine |
	FupLetAny |
	FupCall |
	FupIndex |

	"{" ~ OperatorExpression ~ "}" |
	FupCond |
	FupList |

	SchemeExpression |

	Number |
	Boolean |
	Character |
	String |
	Name
}

// QUOTE
FupQuote = @{
	"'" ~ "(" ~ FupQuoteInner* ~ ")" |
	"`" ~ "(" ~ FupQuoteInner* ~ ")" |
	"'" ~ Identifier
}
FupQuoteInner = @{
	(!("(" | ")") ~ ANY)+ |
	"(" ~ FupQuoteInner* ~ ")"
}

// DEFINE
FnParameters = {
	(Name ~ ("," ~ Name)* ~ ","?)?
}
FupDefine = {
	"define" ~ Name ~ "=" ~ OperatorExpression ~ ";" |
	"define" ~ Name ~ "(" ~ FnParameters ~ ")" ~ "{" ~ OperatorExpression* ~ "}"
}

// LET
FupLetAssignments = {
	Name ~ "=" ~ OperatorExpression ~ ("," ~ FupLetAssignments)*
}
FupLet = {
	"let" ~ FupLetAssignments ~ OperatorExpression*
}
FupLetRec = {
	"letrec" ~ FupLetAssignments ~ OperatorExpression*
}
FupLetStar = {
	"let*" ~ FupLetAssignments ~ OperatorExpression*
}
FupLetAny = {
	FupLetStar |
	FupLetRec |
	FupLet
}

// CALL
FnArguments = {
	(OperatorExpression ~ ("," ~ OperatorExpression)+ ~ ","?) | (OperatorExpression ~ ",") | ","
}
FupCall = {
	Callable ~ "(" ~ FnArguments ~ ")"
}
Callable = {
	"{" ~ OperatorExpression ~ "}" |
	SchemeExpression |
	Name
}

// INDEX
FupIndex = {
	Indexable ~ "[" ~ (FupIndexFull | FupIndexOpenLeft | FupIndexOpenRight | FupIndexExact) ~ "]"
}
FupIndexExact = {
	IndexNumber
}
FupIndexOpenRight = {
	IndexNumber ~ ".."
}
FupIndexOpenLeft = {
	".." ~ IndexNumber
}
FupIndexFull = {
	IndexNumber ~ ".." ~ IndexNumber
}
IndexNumber = @{
	Digit+
}
Indexable = {
	"{" ~ OperatorExpression ~ "}" |
	SchemeExpression |
	Name
}

// COND
FupCond = {
	"cond" ~ "{" ~ (CondArm ~ ("," ~ CondArm)* ~ ","?)? ~ "}"
}
CondArm = {
	OperatorExpression ~ "=>" ~ OperatorExpression
}

// List literal
FupList = {
	"[" ~ "]" |
	"[" ~ OperatorExpression ~ "," ~ "]" |
	"[" ~ OperatorExpression ~ ("," ~ OperatorExpression)+ ~ ","? ~ "]"
}

// Infix operators
FupInfixOp = _{
	OpAppend |
	OpCons |
	OpAdd |
	OpSubtract |
	OpMultiply |
	OpDivide |
	OpModulo |
	OpAnd |
	OpOr |
	OpLowerThanOrEqual |
	OpGreaterThanOrEqual |
	OpLowerThan |
	OpGreaterThan |
	OpEq |
	OpEqv |
	OpEqual |
	OpMathEqual
}
OpAppend = { "++" }
OpCons = { ":" }
OpAdd = { "+" }
OpSubtract = { "-" }
OpMultiply = { "*" }
OpDivide = { "/" }
OpModulo = { "%" }
OpAnd = { "and" }
OpOr = { "or" }
OpLowerThanOrEqual = { "<=" }
OpGreaterThanOrEqual = { ">=" }
OpLowerThan = { "<" }
OpGreaterThan = { ">" }
OpEq = { "is" | "eq?" }
OpEqv = { "eqv?" }
OpEqual = { "==" | "equal?" }
OpMathEqual = { "=" }

// FUP names, subset of Scheme identifiers without special symbols (operators)
Name = @{
	Letter ~ ( "_" | "?" | Letter | Digit )*
}

// Scheme rules
SchemeExpression = {
	"(" ~ ( FupTerm | SchemeExpression | Atom )* ~ ")"
}

Atom = ${
	Number |
	Boolean |
	Character |
	String |
	Identifier
}

Number = @{
	Digit+ ~ ("." ~ Digit*)?
}

// Scheme identifier
Identifier = @{
	(Special | Letter) ~ (Special | Letter | Digit)*
}

Boolean = @{
	"#t" | "#f"
}

Character = @{
	"#\\" ~ CharacterName | "#\\" ~ ANY
}
CharacterName = {
	"space" | "newline"
}

String = @{
	"\"" ~ StringElement* ~ "\""
}
StringElement = _{
	"\\" | "\\\"" | !("\"" | "\\") ~ ANY
}

Special = _{
	"!" | "\"" | "#" | "$" | "%" | "&" | "*" | "+" | "-" | "." | "/" |
	":" | "<" | "=" | ">" | "?" | "@" | "^" | "_" | "|" | "~"
}
Digit = _{ ASCII_DIGIT }
Letter = _{ 'a'..'z' | 'A'..'Z' }

COMMENT = _{ ";" ~ (!"\n" ~ ANY)* ~ ("\n" | EOI) }
WHITESPACE = _{ " " | "\t" | "\n" }
