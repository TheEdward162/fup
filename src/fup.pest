// FUP - Fuck Unclosed Parens

Input = _{ SOI ~ AugmentedExpression+ ~ EOI }

AugmentedExpression = _{
	FupExpression |
	SchemeExpression
}

// FUP rules
FupExpression = {
	FupDefine |
	FupTerm ~ (FupInfixOp ~ FupTerm)*
	// TODO let, ...
}

// Atomic FUP expression
FupTerm = {
	"{" ~ FupExpression ~ "}" |
	FupCall |
	FupIndex |
    FupCond |
	SchemeExpression |
	Number |
	Boolean |
	Character |
	String |
	Name
}

// Parameters for a function definition
FnParameters = {
	(Name ~ ("," ~ Name)* ~ ","?)?
}
// Body of a block enclosed in `{}`
BlockBody = {
	AugmentedExpression*
}

// Define special form, with shortcut for function definition
FupDefine = {
	"define" ~ Name ~ "=" ~ AugmentedExpression ~ ";" |
	"define" ~ Name ~ "(" ~ FnParameters ~ ")" ~ "{" ~ BlockBody ~ "}"
}

// Arguments for function call
FnArguments = {
	(AugmentedExpression ~ ("," ~ AugmentedExpression)* ~ ","?)?
}

// Function call
FupCall = {
	Name ~ "(" ~ FnArguments ~ ")"
}

// List indexing
FupIndex = {
	Name ~ "[" ~ IndexNumber ~ IndexTail? ~ "]"
}

IndexNumber = @{
	Digit+
}

IndexTail = {
	".."
}

// Cond expression
FupCond = {
	"cond" ~ "{" ~ (CondArm ~ ("," ~ CondArm)* ~ ","?)? ~ "}"
}

// One arm of cond expression
CondArm = {
	AugmentedExpression ~ "=>" ~ AugmentedExpression
}

// Infix operators
FupInfixOp = _{
    OpAppend |
    OpCons |
    OpAdd |
    OpSubtract |
    OpMultiply |
    OpDivide |
    OpModulo |
    OpAnd |
    OpOr |
    OpLowerThanOrEqual |
    OpGreaterThanOrEqual |
    OpLowerThen |
    OpGreaterThen |
    OpEq |
    OpEqv |
    OpEqual |
    OpMathEqual
}
OpAppend = { "++" }
OpCons = { ":" }
OpAdd = { "+" }
OpSubtract = { "-" }
OpMultiply = { "*" }
OpDivide = { "/" }
OpModulo = { "%" }
OpAnd = { "and" }
OpOr = { "or" }
OpLowerThanOrEqual = { "<=" }
OpGreaterThanOrEqual = { ">=" }
OpLowerThen = { "<" }
OpGreaterThen = { ">" }
OpEq = { "is" | "eq?" }
OpEqv = { "eqv?" }
OpEqual = { "==" | "equal?" }
OpMathEqual = { "=" }

// FUP names, subset of Scheme identifiers without special symbols (operators)
Name = @{
	Letter ~ ( "_" | Letter | Digit )*
}


// Scheme rules
SchemeExpression = {
	"(" ~ ( FupTerm | SchemeExpression | Atom )* ~ ")"
}

Atom = ${
	Number |
	Boolean |
	Character |
	String |
	Identifier
}

Number = @{
	Digit+ ~ ("." ~ Digit*)?
}

// Scheme identifier
Identifier = @{
	(Special | Letter) ~ (Special | Letter | Digit)*
}

Boolean = @{
	"#t" | "#f"
}

Character = @{
	"#\\" ~ CharacterName | "#\\" ~ ANY
}
CharacterName = {
	"space" | "newline"
}

String = @{
	"\"" ~ StringElement* ~ "\""
}
StringElement = _{
	"\\" | "\\\"" | !("\"" | "\\") ~ ANY
}

Special = _{
	"!" | "\"" | "#" | "$" | "%" | "&" | "*" | "+" | "-" | "." | "/" |
	":" | "<" | "=" | ">" | "?" | "@" | "^" | "_" | "|" | "~"
}
Digit = _{ ASCII_DIGIT }
Letter = _{ 'a'..'z' | 'A'..'Z' }

COMMENT = _{ ";" ~ (!"\n" ~ ANY)* ~ ("\n" | EOI) }
WHITESPACE = _{ " " | "\t" | "\n" }
